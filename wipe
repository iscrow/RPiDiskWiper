#!/bin/bash

LOGFILE="/tmp/wipe.log"

dev=$1
disk="/dev/$dev"
mntpath="/mnt/$(basename "$disk")1"
statefile="/tmp/$dev"
green="/sys/class/leds/led0"
redn="/sys/class/leds/led1"

DEBUG=1		# Debug enabled. Log to $LOGFILE
#DEBUG=		# Debug disabled. Do not log.

if [ "$DEBUG" ]; then
#	exec >> $LOGFILE		# This causes all stdout of the script to be sent to the logfile
	exec 2>&1
fi

# Set LED status. Example: led 0 heartbeat
function ledtrigger() {
	# Trigger can be: timer oneshot heartbeat backlight gpio cpu0 cpu1 cpu2 cpu3 default-on input panic mmc0
	# Default led0 (Green: Status) trigger: mmc0
	# Default led1 (  Red: Power ) trigger: input
	case "$1" in
	green)
		echo $2 > $green/trigger
		;;
	red)
		echo $2 > $red/trigger
		;;
	both)
		echo $2 > $green/trigger
		echo $2 > $red/trigger
		;;
	esac
}

# Create/remove the appropriate state flags in /tmp that allow multiple instances of this script
# wiping disks in parallel to agree on what the LEDs should be doing.
function setstate() {
	state=$1
	case "$state" in
	"wiping")
		rm $statefile.* 2>/dev/null
		touch "$statefile.wipingstate"
		;;
	"done")
		rm $statefile.* 2>/dev/null
		;;
	"error")
		rm $statefile.* 2>/dev/null
		touch "$statefile.errorstate"
		;;
	esac
}

function pulse() {
	case "$1" in
	green)
		echo 255 > $green/brightness
		sleep 0.1
		echo   0 > $green/brightness
		;;
	red)
		echo 255 > $red/brightness
		sleep 0.1
		echo   0 > $red/brightness
		;;
	both)
		echo 255 > $green/brightness
		echo 255 > $red/brightness
		sleep 0.1
		echo   0 > $green/brightness
		echo   0 > $red/brightness
		;;
	esac
}

# Log to the $LOGFILE is DEBUG is enabled. Example: log "my message"
function log() {
	[ "$DEBUG" ] && echo $(date) :: $disk :: $* >> $LOGFILE
}

# Log to $LOGFILE lines read on stdin instead of passed as parameters
# Expample: echo "my message" | inlog
function inlog() {
	while read -r line; do 
		[ "$DEBUG" ] && log "$line";
	done
}

function wiperslist() {
    echo $(ls /tmp/*.wipingstate 2>/dev/null)
}

function blink() {
    wipers=$(wiperslist)
    [[ "$wipers" =~ ^/tmp/$dev ]] && master=1 || master=""
	if [ $master ]; then
		ledtrigger both none
	fi
    for process in $wipers; do
        [ $master ] && pulse both
        sleep 0.4
    done
}


# Sanity check that is called before each major step to ensure the disk is still there.
function check() {
	if [ ! -b "$disk" ] || [[ ! "$(sudo blockdev --getsize64 $disk 2>/dev/null)" =~ ^[0-9]+$ ]]; then
		log "Disk disappeared prematurely! Aborting!"
		exit 1
	fi
}

# If the disk is removed before we're done, systemd will kill us. Catch that signal and do some cleanup.
interrupted() {
	setstate done
	log "Ooopsies! Looks like our device disappeared. Systemd is killing us. Cleaning up and exiting."
	umount $mntpath &>/dev/null
	rmdir -r $mntpath &>/dev/null
	[ "$(wiperslist | wc -l)" ] && ledtrigger red input
	exit 1
}

# Catch the INT and TERM signals
trap interrupted INT TERM

log "Disk Inserted."
if [[ ! "$disk" =~ \/dev\/sd[a-z]$ ]]; then
	log "Disk $disk does not match the required pattern /dev/sd*. Ignoring!"
	exit 1
fi

if [[ ! "$(sudo blockdev --getsize64 $disk 2>/dev/null)" =~ ^[0-9]+$ ]]; then
	log "Disk does not have a valid size. Ignoring!"
	exit 1
fi

log "Disk matches pattern /dev/sd*. Wiping!"

# Check if the disk is still there
check

### Select wipe strategy ###
(
# man shred for more options
#shred -v --iterations=1 "$disk" 2>&1 | inlog

# Faster than shred. You need to have pv installed for this
openssl enc -aes128 -k "wiper" < /dev/zero | pv -ftrb 2>&1 > "$disk" | stdbuf -oL tr '\r' '\n' | inlog

# Faster than shred. No pv required but no progress is logged.
#openssl enc -aes128 -k "wiper" < /dev/zero > "$disk"
) &

### End wipe strategies ###

# Capture the wiper PID
PID=$!

setstate wiping
# Blink the LEDs while the wiper is running
while kill -0 "$PID" >/dev/null 2>&1; do
    blink
    sleep 1
done
[ "$(wiperslist | wc -l)" ] && ledtrigger red input

setstate done

# Create a partition table on the disk with one partition filling the disk.
log "Wiping Complete. Partitioning."
(
echo o # Create a new empty DOS partition table
echo n # Add a new partition
echo p # Primary partition
echo 1 # Partition number
echo   # First sector (Accept default: 1)
echo   # Last sector (Accept default: varies)
echo w # Write changes
) | fdisk $disk

# Check if the disk is still there
check

# Format the created partition
log "Partitioning complete. Formatting."
mkfs.vfat -F 32 ${disk}1
#mkfs.ntfs -F ${disk}1
#mkfs.ext3 -F ${disk}1
#mkfs.xfs -F ${disk}1

# Check if the disk is still there
check

log "Formatting complete. Timestamping."

# Mount the partition
mkdir $mntpath
mount ${disk}1 $mntpath

# Check if the disk is still there
check

# Create a timestamp file
touch  $mntpath/$(date +"%Y-%m-%d--%H-%M-%S")

# Unmount and cleanup mount point
umount $mntpath
rm -r $mntpath

# Turn on done LED pattern

log "Done in $SECONDS seconds!"
